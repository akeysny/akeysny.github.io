I"Ì<h2 id="background">Background</h2>
<p>Of the numerous vulnerabilities related to browser-based web applications, cross-site scripting (XSS) is one of the most common and damaging vulnerabilities. The browser is a sophisticated piece of software, not just because it must render content efficiently and portably, but it must also execute associated JavaScript. As a general rule, any system that executes code can be made to execute malicious code if proper protections aren‚Äôt used. XSS is a technique in which an attacker is able to ‚Äútrick‚Äù a browser into executing malicious JavaScript that‚Äôs not part of the legitimate page. Even though web developers have known about it for years, it‚Äôs still easy to let an XSS vulnerability slip through the cracks.</p>

<p><img src="/img/posts/web-security/cyber.jpeg" alt="IMDb page" /></p>

<h2 id="types-of-xss">Types of XSS</h2>
<p>There are three types of Cross-Site Scripting.</p>

<ul>
  <li>Reflected</li>
</ul>

<p>Data from URLs or forms
Runs immediately when data is received</p>

<p>As an example, imagine a search box at the top of a website. When a user submits a search term, the application searches the database for products matching that term. If no products are found, it responds with:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="no">No</span> <span class="n">results</span> <span class="n">were</span> <span class="n">found</span> <span class="ss">for: </span><span class="o">&lt;</span><span class="p">?</span><span class="n">php</span> <span class="n">echo</span> <span class="vg">$term</span><span class="p">;</span> <span class="sc">?&gt;</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span></code></pre></figure>

<p>If the search request was:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">GET</span> <span class="sr">/search.php?term=candy</span></code></pre></figure>

<p>The application would return:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="no">No</span> <span class="n">results</span> <span class="n">were</span> <span class="n">found</span> <span class="ss">for: </span><span class="n">candy</span><span class="o">&lt;</span><span class="sr">/h1&gt;</span></code></pre></figure>

<p>Notice that the data being submitted in the URL query is not being sanitized to remove or disable JavaScript before it is output to HTML.</p>

<ul>
  <li>Stored</li>
</ul>

<p>Data from database, cookies, and sessions
Runs later when data is retrieved</p>

<ul>
  <li>DOM-based</li>
</ul>

<p>Data generated by JavaScript
Runs when user triggers JavaScript events</p>

<h2 id="a-positive-xss-prevention-model">A Positive XSS Prevention Model</h2>

<p>This article treats an HTML page like a template, with slots where a developer is allowed to put untrusted data. These slots cover the vast majority of the common places where a developer might want to put untrusted data. Putting untrusted data in other places in the HTML is not allowed. This is an ‚Äúallow list‚Äù model, that denies everything that is not specifically allowed.</p>

<p>Given the way browsers parse HTML, each of the different types of slots has slightly different security rules. When you put untrusted data into these slots, you need to take certain steps to make sure that the data does not break out of that slot into a context that allows code execution. In a way, this approach treats an HTML document like a parameterized database query - the data is kept in specific places and is isolated from code contexts with encoding.</p>

<p>This document sets out the most common types of slots and the rules for putting untrusted data into them safely. Based on the various specifications, known XSS vectors, and a great deal of manual testing with all the popular browsers, we have determined that the rules proposed here are safe.</p>

<p>The slots are defined and a few examples of each are provided. Developers SHOULD NOT put data into any other slots without a very careful analysis to ensure that what they are doing is safe. Browser parsing is extremely tricky and many innocuous looking characters can be significant in the right context.</p>

<h2 id="why-cant-i-just-html-entity-encode-untrusted-data">Why Can‚Äôt I Just HTML Entity Encode Untrusted Data</h2>

<p>HTML entity encoding is okay for untrusted data that you put in the body of the HTML document, such as inside a</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&lt;</span><span class="n">div</span><span class="o">&gt;</span></code></pre></figure>
<p>tag. It even sort of works for untrusted data that goes into attributes, particularly if you‚Äôre religious about using quotes around your attributes.</p>

<p>But HTML entity encoding doesn‚Äôt work if you‚Äôre putting untrusted data inside a</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&lt;</span><span class="n">script</span><span class="o">&gt;</span></code></pre></figure>
<p>tag anywhere, or an event handler attribute like onmouseover, or inside CSS, or in a URL. So even if you use an HTML entity encoding method everywhere, you are still most likely vulnerable to XSS. You MUST use the encode syntax for the part of the HTML document you‚Äôre putting untrusted data into. That‚Äôs what the rules below are all about.</p>

:ET